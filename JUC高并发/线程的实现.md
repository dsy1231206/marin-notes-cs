# 线程的实现

###### 实现线程主要有三种方式：使用内核线程实现（1：1实现），使用用户线程实现（1：N实现），使用用户线程加轻量级进程混合实现（N:M实现）



#### 1、内核线程实现

使用内核线程实现的方式也称为1：1实现。内核线程（kernel-Level Thread，KLT）就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操纵【调度器】（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上。

###### 而程序一般不会直接使用内核线程，而是使用内核线程的一种高级接口：轻量级进程（Light Weight Process,LWP），轻量级进程就是我们通常意义上说的线程。由于每个轻量级进程都需要一个内核线程支持，就构成一对一的线程模型。 

![image-20220818095709793](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220818095709793.png)

由于内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即使其中某一个轻量级进程在系统调用中被阻塞了，也不会影响进程的运行。

但由于是基于内核线程实现的，所以各种线程操作都需要进行系统调用，而系统调用的代价较高，需要在用户态和内核态之间来回切换。其次，每个轻量级进程是由内核线程支持的，需要消耗一定的内核资源。



#### 2、用户线程实现

使用用户线程实现的方式被称为1：N实现。广义上来讲，一个线程只要不是内核线程，都可以被称为用户线程（User Thread）的一种。

###### 而狭义上的用户线程指的是完全建立在用户态的线程库上，内核不能感知到用户线程的存在和实现。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。

如果程序实现得当，这种线程不需要切换到内核态，因此操作是非常快速且低消耗的，也能够支持规模更大的线程数量，部分高性能数据库中的多线程就是由用户线程实现的。

![image-20220818100353813](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220818100353813.png)



#### 3、混合实现

在混合实现下，即存在用户线程也存在轻量级进程。用户线程还是完全建立在用户空间中，而操作系统支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度及处理器映射，并且用户线程中的系统调用要通过轻量级进程来完成。

![image-20220818100752757](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220818100752757.png)



#### 4、Java线程的实现

大多数平台上，例如HotSpot虚拟机都是采用1：1的模型，把每一个Java线程映射到操作系统的原生线程。

但也有少部分虚拟机采用N:M的模型和混合模型



#### 5、Java线程调度

###### 线程调度是指系统为线程分配处理器使用权的过程。

调度方式有两种，分别是协同式线程调度（Cooperative Threads-Scheduling）和抢占式线程调度（Preemptive Threads-Scheduling）。

###### 1）协同式线程调度的多线程系统，线程的执行时间完全由线程本身控制，线程把自己的工作执行完之后，要主动通知系统切换到另一个线程上。

协同式调度的最大好处就是实现简单，切换线程对于线程本身是可知的，所以不会存在线程同步的问题。但线程执行时间不可控制，就很可能会有程序阻塞在某一个线程上，造成系统崩溃。

###### 2）抢占式线程调度，每个线程由操作系统来分配运行时间，线程切换不由线程本身决定。例如Java中，线程可以通过Thread::yield()来主动让出CPU执行权，但线程是没法主动获取CPU执行权的。

##### Java使用的方式就是抢占式线程调度。



###### 拓展：

虽然Java的线程调度是抢占式调度，但开发者可以主动【建议】操作系统给某些线程多分配一些时间。Java语言一共设置了10个线程的优先级，从Thread.MIN_PRIORITY到Thread.MAX_PRIORITY。两个线程同时处于Ready状态时，优先级越高的线程越容易被调度。

不过，线程优先级并不是稳定的调控手段，主流Java虚拟机的线程是映射到系统的内核线程上的，所以线程的调度最终还是操作系统决定。但操作系统的线程优先级并不见得与Java线程优先级能一一对应。

例如Solaris中线程有2147483648种优先级，但Windows中只有7种优先级。如果操作系统的优先级数量比Java少，那么可能有好几个Java线程优先级对应到同一个操作系统的优先级。

例如图中对应的优先级：

![image-20220818103403730](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220818103403730.png)



#### 6、线程状态转换

##### Java定义了6种线程状态：

###### 1）新建：创建后尚未启动的线程

###### 2）运行：包括Running和Ready，处于运行状态的线程可能正在执行，也可能等待操作系统为它分配CPU

###### 3）无限期等待（Waiting）：等待状态的线程不会被操作系统分配运行时间，他们只能等待其他线程唤醒。

​		怎么进入等待状态？

​		Object::wait()，没有设置Timeout

​		Thread::join()，没有设置Timeout

​		LockSupport::park()

###### 4）期限等待（Timed Waiting）：不会被操作系统分配运行时间，也不需要等待其他线程唤醒，因为过一段时间他们会自动被系统唤醒。

​		进入期限等待：

​		Thread::sleep()

​		设置了Timeoue的Object::wait()

​		设置了Timeout的Thread::join()

​		LockSupport::parkNanos()

​		LockSupport::parkUntil()

###### 5）阻塞（Blocked）：阻塞状态和等待状态的区别在于，阻塞状态在等待着获取“排他锁”，这个时间将在另一个线程放弃这个锁的时候发生。

###### 6）结束（Terminated）：已终止线程的状态，结束运行。

![image-20220818104254634](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220818104254634.png)