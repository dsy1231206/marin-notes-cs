# Redis（10）事务

###### Redis事务是一个单独的隔离操作，事务中的所有命令都会序列化书顺序执行。不会被其他客户端发来的命令打断。

## 1、Multi/Exec/discard

输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec后，redis会将之前队列中的命令依次执行。组队过程中可以通过discard命令来放弃组队。

![image-20220706094407877](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220706094407877.png)



## 2、事务的错误处理

###### 组队过程中，如果一个命令失败，则全部失败

###### 在执行过程中，如果一个命令失败，则这个命令失败，其他命令成功



## 3、事务冲突的问题

#### 1）悲观锁

每次拿数据的时候都上锁，别的线程进来都会被阻塞

并发性能低

#### 2）乐观锁

利用版本号，每次更新数据的时候检查当前数据版本号和数据库版本号是否一致。



## 4、WATCH key [key...]

在执行multi之前，先执行watch key1 [ley2...]，监视一个key或者多个key，如果事务执行之前这个key被其他命令改动，则事务被打断

WATCH命令就相当于乐观锁

unwatch：取消对key的监视



## 5、Redis事务三特性

###### 1）单独的隔离操作

​		事务中所有命令都会序列化、按顺序地执行。事务执行过程中，不会被其他客户端发送来的命令打断

###### 2）没有隔离级别的概念

​		队列中的命令提交之前都不会实际执行

###### 3）不保证原子性

​		在执行过程中，一条命令失败，其他命令可以正常执行



## 6、秒杀案例

###### 正常写秒杀流程，但是高请求高并发下，会出现超时和超卖的问题

##### 1）连接超时

使用连接池配置类：JedisPoolConfig

##### 2）结局超卖

添加乐观锁：

```java
jedis.watch(key)
```

添加事务：

```java
Transaction multi = jedis.multi();//事务
```

```java
//组队操作
multi.decr(kcKey);
multi.sadd(userKey,uid);
```

```java
multi.exec();//执行
```



##### 3）乐观锁造成库存遗留的问题

一个人修改了版本号之后，其他并发请求发现版本号不同，于是停止了接下来的操作。



## 7、LUA脚本

将复杂的redis操作写成一个脚本，一次提交给redis执行，减少反复连接redis的操作

