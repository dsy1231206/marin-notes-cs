# Redis（11）持久化

## 1、RDB（Redis DataBase）

在指定时间间隔内将内存中的数据集快照写入硬盘中。



##### 备份是如何进行的？

Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，等持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程不进行任何IO操作，这就确保了极高的性能。

###### RDB的缺点是最后一次持久化之后的数据可能丢失。



##### 命令save

手动保存，配置文件中可以设置，例如15min内有1个key发生改变，就持久化

在配置文件中改：save 300 5（5分钟以内有个key发生变化就持久化，超时了就重新计算时间）



##### 优势

适合大规模的数据恢复

对数据完整性和一致性要求不高更适合使用

节省磁盘空间

恢复速度快



##### 劣势

fork的时候，内存中的数据克隆了一份，大致2倍的膨胀性

虽然Redis在fork的适合使用了写时拷贝技术，但如果数据庞大时还是比较消耗性能

在备份周期在一定间隔时间做一次备份，如果redis意外down的话，就会丢失最后一次快照后的修改



## 2、AOF（Append Only File）

以日志的形式来记录每一个写操作（增量保存），将redis执行过的所有写指令记录下来（读操作不记录），只能追加文件不能改写文件。redis启动之初会读取该文件重新构建数据。

###### 换句话说，Redis重启的话就根据日志文件的内容将所有写指令重新执行一次。



##### AOF持久化流程

1）客户端的请求命令会被append追加到AOF缓冲区内

2）AOF缓冲区根据AOF持久化策略[always,everysec,no]将操作sync同步到磁盘AOF文件中

3）AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量

4）Redis服务重启时，会加载AOF文件，达到恢复数据的目的



##### AOF默认不开启

redis.conf文件中，有 appendonly no，改为yes之后才开启

```
appendonly no

appendfilename "appendonly.aof" #文件名
```

文件生成路径和dump.rdb相同



##### AOF和RDB同时开启，redis听谁的？

都开启的话，系统默认取AOF的内容



##### 如果AOF文件异常，Redis重启的时候会报错、

```
Could not connect to Redis at 127.0.0.1:6379: Connection refused
```

可以使用命令对AOF文件进行修复



##### AOF同步频率设置

appendfsync always：每次写操作都同步日志

appendfsync everysec：每秒同步

appendfsync no：redis不主动进行同步，把同步时机交给操作系统



##### Rewrite压缩

AOF文件持续增长而过大时，会fork出一条新进程来将文件重写（也是先写临时文件最后rename）

redis4.0版本后的重写。实质上就是把rdb的快照以二进制的形式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作。



##### 优势

备份机制更文件，丢失数据的概率更低

可读的日志文本，通过操作AOF文件，可以处理误操作



##### 劣势

比起RDB占用更多的磁盘空间

恢复备份速度要慢

每次读写都同步的话，会造成一定的性能压力

存在个别BUG，造成不能恢复